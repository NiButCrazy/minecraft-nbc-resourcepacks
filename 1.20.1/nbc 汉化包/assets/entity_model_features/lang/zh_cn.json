{
  "entity_model_features.title": "实体模型特性",
  "entity_model_features.config.general": "常规",
  "entity_model_features.config.general.tooltip": "常规设置",
  "entity_model_features.config.substitute_vanilla": "替换丢失的模型部分",
  "entity_model_features.config.substitute_vanilla.tooltip": "EMF 将尝试用原版模型部分\n替换 .jem 模型文件中缺失的部分",
  "entity_model_features.config.optimizations": "优化",
  "entity_model_features.config.optimizations.tooltip": "动画优化的相关设置",
  "entity_model_features.config.debug": "调试",
  "entity_model_features.config.debug.tooltip": "调试选项，有助于解决一些问题",
  "entity_model_features.config.green_render": "使自定义模型变绿",
  "entity_model_features.config.green_render.tooltip": "使 CEM 生物显示为绿色，\n以便将它们与原版模型区分开来，\n并检查它们是否被正确加载",
  "entity_model_features.config.log_models": "记录模型构建信息",
  "entity_model_features.config.log_models.tooltip": "将模型创建的调试数据打印到日志中",
  "entity_model_features.config.vanilla_render.normal": "普通",
  "entity_model_features.config.vanilla_render.offset": "偏移",
  "entity_model_features.config.vanilla_render": "显示原版模型模式",
  "entity_model_features.config.vanilla_render.tooltip": "尝试将原版模型与自定义模型一起渲染以进行比较。\n它不会有动画，因此一些位置可能会有些奇怪",
  "entity_model_features.config.log_math": "记录动画计算",
  "entity_model_features.config.log_math.tooltip": "将动画计算的调试数据打印到日志中。\n警告：会导致极大的卡顿！",
  "entity_model_features.config.options": "选项和修复",
  "entity_model_features.config.options.tooltip": "基本功能或模组兼容性修复的各种选项",
  "entity_model_features.config.tools": "工具",
  "entity_model_features.config.tools.tooltip": "帮助模型制作或区分自定义模型的可选工具",
  "entity_model_features.config.force_models": "尽量防止 EMF 模型被覆盖",
  "entity_model_features.config.force_models.tooltip": "将尝试强制实体渲染器使用 EMF\n设置的模型，这可以覆盖其他模组对原版模型的更改。\n此功能不适用于所有模组",
  "entity_model_features.config.unknown_model_print_mode.log": "仅日志",
  "entity_model_features.config.unknown_model_print_mode.log_jem": "日志和 .jem 文件",
  "entity_model_features.config.unknown_model_print_mode.tooltip": "这将为 EMF 可以访问的任何未知或已修改模型\n打印出其信息或完整的 .jem 文件。\n注意：.jem 文件可能还不完美，但会为您提供一个起点",
  "entity_model_features.config.unknown_model_print_mode": "打印出未知型号信息",
  "entity_model_features.config.physics": "Physics 模组补丁 #2",
  "entity_model_features.config.physics.tooltip": "如果启用了 Physics 模组，则只会在死亡时渲染原始的原版模型零件。\n这部分有效，但不是一个完美的解决方案",
  "entity_model_features.config.texture_override_mode.emf": "尝试使用 EMF 代码",
  "entity_model_features.config.texture_override_mode.dont": "忽略纹理覆盖",
  "entity_model_features.config.texture_override_mode.iris": "先尝试使用 Iris",
  "entity_model_features.config.texture_override_mode.tooltip": "这将控制 EMF 如何处理具有覆盖纹理集的渲染子模型。\n例如，如果爬行者模型具有头部子模型的单独纹理。\n有两种方法可以做到这一点：依靠 EMF 的代码，或者依靠 Iris 模组的特性。\nEMF 的代码“有效”，但我不是渲染缓冲区的专家，这可能会导致问题。\nIris 的特性使用起来非常简单，且看似安全/稳定，但我被告知这不是 Iris 的预期行为。\n如果未安装 Iris，此选项将默认使用 EMF 代码。\n除非在调试子模型的纹理覆盖，否则几乎总是应该保持默认值",
  "entity_model_features.config.texture_override_mode": "子模型纹理处理",
  "entity_model_features.config.physics.1": "使用原版模型",
  "entity_model_features.config.physics.2": "使用 EMF（CEM）模型",
  "entity_model_features.config.render.normal": "正常",
  "entity_model_features.config.render.green": "闪光绿色",
  "entity_model_features.config.render.lines": "线框",
  "entity_model_features.config.render.none": "已禁用",
  "entity_model_features.config.render": "如何呈现自定义模型部件",
  "entity_model_features.config.render.tooltip": "更改自定义模型零件的渲染方式，这不会影响原版模型零件。\n正常 = 正常渲染\n绿色闪烁 = 自定义零件将闪烁绿色\n线框 = 仅渲染模型零件的轮廓\n禁用 = 自定义模型零件将不渲染",
  "entity_model_features.config.animate_once": "为每个实体设置一次模型动画",
  "entity_model_features.config.animate_once.tooltip": "默认情况下启用。\n此设置使实体模型对每个渲染的实体仅进行一次动画处理。\n这在游戏中是完全正常的，但是\n物品栏屏幕中可见的生物可能会奇怪地闪烁，\n特别是如果它代表您在世界中已经可以看到的真实生物",
  "modmenu.descriptionTranslation.entity_model_features": "这是 ETF 模组的扩展，它增加了对 OptiFine 格式自定义实体模型（CEM）资源包的支持。\n同时仍允许您禁用此功能以使用不同的模型模组:)",
  "entity_model_features.config.optifine_fallback_properties": "使用后备 .properties 文件",
  "entity_model_features.config.optifine_fallback_properties.tooltip": "如果启用，当找不到常规的 .properties 文件时，EMF 将尝试加载一个后备的 .properties 文件。\n例如：如果 pig_baby.properties 不存在，pig_baby.jem 将回退到使用 pig.properties。\nOptiFine 仅支持此类后备机制，实际上并不允许像 pig_baby.properties 这样的针对单个模型的属性文件",
  "entity_model_features.config.show_reload_error_toast": "显示重载错误提示",
  "entity_model_features.config.show_reload_error_toast.tooltip": "如果启用，当资源重载期间发生错误时，将会显示一个提示消息。\n这有助于了解重载过程中是否出现了问题",
  "entity_model_features.config.load_warn.1": "EMF 遇到了加载错误",
  "entity_model_features.config.load_warn.3": "请检查您的日志或 EMF 设置以获取详情",
  "entity_model_features.config.load_warn.2": "EMF 可以从 模型 > 调试 > 中再次记录这些错误",
  "entity_model_features.config.load_warn.title": "再次记录所有加载错误",
  "entity_model_features.config.load_warn.title2": "再次记录所有加载错误（含堆栈追踪）",
  "entity_model_features.config.load_warn.tooltip": "此选项会将上一次资源重载期间遇到的所有 EMF 加载错误，\n按其发生的顺序重新打印到日志中。\n此处并非所有错误都很有用，因为它们可能缺少周围的日志上下文",
  "entity_model_features.config.optifine_floor": "UV 坐标取整",
  "entity_model_features.config.optifine_floor.tooltip": "OptiFine 会对自定义方块 UV 值进行向下取整，\n即让它们都变成整数。\n启用此设置将使 EMF 执行相同的操作。\n如果 EMF 发现某个模型的 UV 值未取整，也会记录日志",
  "entity_model_features.config.optifine_syntax": "CEM 动画语法限制",
  "entity_model_features.config.optifine_syntax.tooltip": "如果启用，将强制执行 OptiFine 的 CEM 语法限制，例如：\n动画中的骨骼 ID 不能以 _ 或数字开头。\n数字不能以 '.' 开头，例如 '.9'。\n无法在动画中引用名为 'render' 的骨骼。\n启用此设置后，任何违反这些规则的动画都会被记录错误并失效",
  "entity_model_features.config.models.explain": "此处可见的并非所有部分都能导出，\n只有已声明的部分才会导出。\n您可以在导出后查看游戏日志，以获取缺失部分的变换细节",
  "entity_model_features.config.optifine_subfolders": "子文件夹模型必须有变体",
  "entity_model_features.config.optifine_subfolders.tooltip": "在 OptiFine 中，模型文件的子文件夹选项仅在该模型有变体时才有效。\n例如：'optifine/cem/skeleton/skeleton.jem' 只有在存在变体时才会加载，\n例如 'optifine/cem/skeleton/skeleton2.jem' 或一个 .properties 文件。\n此设置将使 EMF 也强制执行此规则，\n如果 EMF 发现一个没有变体的模型，将会记录日志",
  "entity_model_features.config.debug_right_click": "右键点击实体时显示 EMF 调试数据",
  "entity_model_features.config.debug_right_click.tooltip": "如果启用，右键点击实体时，\n会将 EMF 调试信息打印到日志和聊天栏中",
  "entity_model_features.config.ebe_config_modify": "Enhanced Block Entities (EBE) 模组补丁",
  "entity_model_features.config.ebe_config_modify.tooltip": "如果启用，这将允许 EMF 修改 EBE 模组的配置，\n以在某个方块实体实际加载了自定义 EMF 模型时，\n为其禁用 EBE。\nEMF 之后无法自动重新启用这些设置，\n如果您需要，必须手动操作",
  "entity_model_features.config.function_explanation.abs": "abs(x)\n获取一个数的绝对值。会将负数变为正数",
  "entity_model_features.config.function_explanation.acos": "acos(x)\n获取 x 的反余弦值",
  "entity_model_features.config.function_explanation.asin": "asin(x)\n获取 x 的反正弦值",
  "entity_model_features.config.function_explanation.atan": "atan(x)\n获取 x 的反正切值",
  "entity_model_features.config.function_explanation.atan2": "atan2(y, x)\n获取正 X 轴与点 (x, y) 之间的夹角",
  "entity_model_features.config.function_explanation.catmullrom": "catmullrom(k, x, y, z, w)\n使用 Catmull-Rom 样条函数，在 x 和 y 之间进行插值，控制点为 z 和 w",
  "entity_model_features.config.function_explanation.ceil": "ceil(x)\n将 x 向上舍入到最接近的整数",
  "entity_model_features.config.function_explanation.clamp": "clamp(x, min, max)\n将一个数限制在 min 和 max 之间",
  "entity_model_features.config.function_explanation.cos": "cos(x)\n获取 x 的余弦值",
  "entity_model_features.config.function_explanation.nbt": "nbt(x,y)\n一个布尔函数，如果实体的 NBT 标签 x 与查询 y 匹配，则返回 true。\nx 等同于 NBT 随机属性中 'nbt.<n>.' 之后的内容。\ny 等同于 NBT 随机属性中 '=' 之后的内容。\n例如：NBT 属性中的 'nbt.1.SleepingX=exists:true' 在动画函数中应写作 'nbt(SleepingX,exists:true)'",
  "entity_model_features.config.function_explanation.cubicbezier": "cubicbezier(k, x, y, z, w)\n使用三次贝塞尔样条函数，在 x 和 y 之间进行插值，控制点为 z 和 w",
  "entity_model_features.config.function_explanation.degdiff": "degdiff(x, y)\n返回两个角度值 x 和 y 之间的最短角度差（单位：度）",
  "entity_model_features.config.function_explanation.easeinback": "easeinback(k, x, y)\n使用缓入回弹函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinbounce": "easeinbounce(k, x, y)\n使用缓入弹跳函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeincirc": "easeincirc(k, x, y)\n使用缓入圆形函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeincubic": "easeincubic(k, x, y)\n使用缓入立方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinelastic": "easeinelastic(k, x, y)\n使用缓入弹性函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinexpo": "easeinexpo(k, x, y)\n使用缓入指数函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutback": "easeinoutback(k, x, y)\n使用缓入缓出回弹函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutbounce": "easeinoutbounce(k, x, y)\n使用缓入缓出弹跳函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcirc": "easeinoutcirc(k, x, y)\n使用缓入缓出圆形函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcubic": "easeinoutcubic(k, x, y)\n使用缓入缓出立方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutelastic": "easeinoutelastic(k, x, y)\n使用缓入缓出弹性函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutexpo": "easeinoutexpo(k, x, y)\n使用缓入缓出指数函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquad": "easeinoutquad(k, x, y)\n使用缓入缓出二次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquart": "easeinoutquart(k, x, y)\n使用缓入缓出四次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquint": "easeinoutquint(k, x, y)\n使用缓入缓出五次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutsine": "easeinoutsine(k, x, y)\n使用缓入缓出正弦函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquad": "easeinquad(k, x, y)\n使用缓入二次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquart": "easeinquart(k, x, y)\n使用缓入四次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquint": "easeinquint(k, x, y)\n使用缓入五次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeinsine": "easeinsine(k, x, y)\n使用缓入正弦函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutback": "easeoutback(k, x, y)\n使用缓出回弹函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutbounce": "easeoutbounce(k, x, y)\n使用缓出弹跳函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcirc": "easeoutcirc(k, x, y)\n使用缓出圆形函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcubic": "easeoutcubic(k, x, y)\n使用缓出立方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutelastic": "easeoutelastic(k, x, y)\n使用缓出弹性函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutexpo": "easeoutexpo(k, x, y)\n使用缓出指数函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquad": "easeoutquad(k, x, y)\n使用缓出二次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquart": "easeoutquart(k, x, y)\n使用缓出四次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquint": "easeoutquint(k, x, y)\n使用缓出五次方函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutsine": "easeoutsine(k, x, y)\n使用缓出正弦函数在 x 和 y 之间进行插值\n\n示例见：https://easings.net/",
  "entity_model_features.config.function_explanation.exp": "exp(x)\n获取 e（欧拉常数）的 x 次幂",
  "entity_model_features.config.function_explanation.floor": "floor(x)\n将 x 向下舍入到最接近的整数",
  "entity_model_features.config.function_explanation.fmod": "fmod(x, y)\n类似于 % 运算符，但返回值的符号始终与除数相同",
  "entity_model_features.config.function_explanation.frac": "frac(x)\n获取 x 的小数部分（小数点后的数值）",
  "entity_model_features.config.function_explanation.hermite": "hermite(k, x, y, z, w)\n使用 Hermite 样条函数，在 x 和 y 之间进行插值，控制点为 z 和 w",
  "entity_model_features.config.function_explanation.if": "if(cond, val, [cond2, val2, ...], val_else)\n根据一个或多个条件选择一个值",
  "entity_model_features.config.function_explanation.keyframe": "keyframe(k, a, b, c,...)\n根据当前帧 'k' 和关键帧平滑地在值之间插值。'a' 对应 'k=0'，'b' 对应 'k=1'，'c' 对应 'k=2'，以此类推",
  "entity_model_features.config.function_explanation.keyframeloop": "keyframeloop(k, a, b, c,...)\n根据当前帧 'k' 和关键帧平滑地在值之间插值。'a' 对应 'k=0'，'b' 对应 'k=1'，'c' 对应 'k=2'，以此类推，但当 'k' 大于关键帧数量时，动画会循环回到 'a' 帧",
  "entity_model_features.config.function_explanation.lerp": "lerp(k, x, y)\n在 X 和 Y 之间进行线性插值",
  "entity_model_features.config.function_explanation.log": "log(x)\n获取 x 的自然对数",
  "entity_model_features.config.function_explanation.max": "max(x, y, ...)\n从一组数字中获取最大值",
  "entity_model_features.config.function_explanation.min": "min(x, y ,...)\n从一组数字中获取最小值",
  "entity_model_features.config.function_explanation.pow": "pow(x, y)\n获取 x 的 y 次幂",
  "entity_model_features.config.function_explanation.print": "print(id, n, x)\n每 N 帧打印一次值 \"x\"",
  "entity_model_features.config.function_explanation.printb": "printb(id, n, x)\n每 N 帧打印一次布尔值 \"x\"",
  "entity_model_features.config.function_explanation.quadbezier": "quadbezier(k, x, y, z)\n使用二次贝塞尔样条函数，在 x 和 y 之间进行插值，控制点为 z",
  "entity_model_features.config.function_explanation.raddiff": "raddiff(x, y)\n返回两个弧度值 x 和 y 之间的最短角度差（单位：弧度）",
  "entity_model_features.config.function_explanation.random": "random(seed)\n生成一个 0 到 1 之间的随机数。提供种子将始终返回相同的结果。种子是可选的",
  "entity_model_features.config.function_explanation.round": "round(x)\n将 x 四舍五入到最接近的整数",
  "entity_model_features.config.function_explanation.signum": "signum(x)\n获取 x 的符号（正或负）",
  "entity_model_features.config.function_explanation.sin": "sin(x)\n获取 x 的正弦值",
  "entity_model_features.config.function_explanation.between": "between(x, min, max)\n检查一个值是否在 min 和 max 之间",
  "entity_model_features.config.function_explanation.equals": "equals(x, y, epsilon)\n使用误差范围比较两个浮点值",
  "entity_model_features.config.function_explanation.in": "in(x, val1, val2, ...)\n检查一个值是否等于多个值中的某一个",
  "entity_model_features.config.function_explanation.sqrt": "sqrt(x)\n获取 x 的平方根",
  "entity_model_features.config.function_explanation.tan": "tan(x)\n获取 x 的正切值",
  "entity_model_features.config.function_explanation.ifb": "if(cond, val, [cond2, val2, ...], val_else)\n根据一个或多个条件选择一个值\n仅返回布尔值",
  "entity_model_features.config.function_explanation.randomb": "randomb(seed)\n生成随机布尔值 true|false。提供种子将始终返回相同的结果。种子是可选的",
  "entity_model_features.config.function_explanation.catch": "catch(x,c,id)\n将返回 x，但如果 x 是 NaN 或导致其他动画错误，则会返回 c。\nid 是可选的，如果添加了 id，catch 函数将在游戏日志中用此 id 打印出使用 c 的原因。\n主要用于动画调试，如果有可能触发此情况，您应该真正去修复它",
  "entity_model_features.config.function_explanation.todeg": "todeg(rad)\n将弧度转换为角度",
  "entity_model_features.config.function_explanation.torad": "torad(deg)\n将角度转换为弧度",
  "entity_model_features.config.function_explanation.wrapdeg": "wrapdeg(x)\n将角度值 x 限制在 -180 到 180 度的范围内",
  "entity_model_features.config.function_explanation.wraprad": "wraprad(x)\n将弧度值 x 限制在 -π 到 π 的范围内",
  "entity_model_features.config.large_mob_lod": "为大型生物保留 LOD",
  "entity_model_features.config.large_mob_lod.tooltip": "如果启用，将根据生物的大小\n减弱上述设置对细节层次（LOD）的影响。\n大型生物的跳帧现象将比小型生物更不明显",
  "entity_model_features.config.lod": "动画 LOD 距离",
  "entity_model_features.config.lod.tooltip": "设置动画开始跳帧、降低细节层次（LOD）的距离。\n这有助于提升性能。\n无 = 不跳帧\n16 = 玩家每远离 16 个方块，跳过 1 帧\n数值越低，跳过的帧越多，性能增益越大，\n但动画的帧率会明显降低，尤其是在靠近 LOD 距离时",
  "entity_model_features.config.low_fps_lod": "在低 FPS 下保留 LOD",
  "entity_model_features.config.low_fps_lod.tooltip": "如果启用，将根据您的 FPS\n减弱上述设置对细节层次（LOD）的影响。\n仅在 FPS 低于 60 时生效，因为在低 FPS 下，\n跳帧现象会变得越来越明显",
  "entity_model_features.config.performance": "性能设置",
  "entity_model_features.config.print_mode": "模型导出",
  "entity_model_features.config.print_mode.all_log": "所有模型 - 仅日志",
  "entity_model_features.config.print_mode.all_log_jem": "所有模型 - 日志和 .jem",
  "entity_model_features.config.print_mode.log": "未知模型 - 仅日志",
  "entity_model_features.config.print_mode.log_jem": "未知模型 - 日志和 .jem",
  "entity_model_features.config.print_mode.tooltip": "每次重载资源时，都会为 EMF 能访问的任何模型\n打印出其部件信息或完整的 .jem 文件！\n重载后，.jem 文件可以在 \"MC_DIRECTORY/emf/export\" 目录中找到。\n这些 .jem 文件已准备好用于 Blockbench，\n包含正确的轴心点、方块和 UV。\n“未知模型”指 OptiFine CEM 不支持的模型",
  "entity_model_features.config.debug_hover": "仅在悬停时调试渲染",
  "entity_model_features.config.debug_hover.tooltip": "使上述渲染设置仅应用于客户端悬停的实体。\n即，仅应用于您直接看向的实体",
  "entity_model_features.config.render.lines_texture": "带纹理的线框",
  "entity_model_features.config.render.lines_texture_flash": "带纹理的闪烁线框",
  "entity_model_features.config.update": "模型更新速率",
  "entity_model_features.config.update.tooltip": "设置生物模型为健康值、年龄等变化\n而更新的频率。\n从不 = 永不更新\n慢 = 3-5 秒\n平均 = 约 1 秒\n快 = 小于 1 秒\n即时 = 即时更新（当有数百个生物时可能导致卡顿）",
  "entity_model_features.config.variable_explanation.age": "年龄（以游戏刻为单位）",
  "entity_model_features.config.variable_explanation.is_swinging_right_arm": "如果实体正在挥动右臂则为真。注意：为假并不意味着左臂在挥动",
  "entity_model_features.config.variable_explanation.is_swinging_left_arm": "如果实体正在挥动左臂则为真。注意：为假并不意味着右臂在挥动",
  "entity_model_features.config.variable_explanation.anger_time": "实体剩余的愤怒时间（以游戏刻为单位）。处于攻击状态时初始值为 400-780，失去目标后倒计时至 0",
  "entity_model_features.config.variable_explanation.anger_time_start": "anger_time 的起始值",
  "entity_model_features.config.variable_explanation.day_count": "当前的天数计数",
  "entity_model_features.config.variable_explanation.day_time": "当前一天中的时间（以游戏刻为单位，0-24000）",
  "entity_model_features.config.variable_explanation.death_time": "实体死亡的时间。从 0 计数到 20",
  "entity_model_features.config.variable_explanation.dimension": "当前维度。主世界：0，下界：-1，末地：1",
  "entity_model_features.config.variable_explanation.distance": "实体与客户端玩家的距离（以方块为单位）\n\n虽然 distance 变量是为了方便而添加的，但在 OptiFine 中可以通过以下代码实现相同效果：\n\"var.distance\": \"sqrt(pow(pos_x -player_pos_x, 2) + pow(pos_y - player_pos_y, 2) + pow(pos_z - player_pos_z, 2))\"",
  "entity_model_features.config.variable_explanation.e": "欧拉数\n2.718281.....",
  "entity_model_features.config.variable_explanation.entity_variable": "实体变量的格式为 \"var.<名称>\"（浮点数）或 \"varb.<名称>\"（布尔值）\n\n名称可以是任意字符串，例如 \"var.xyz\"、\"var.last_rx\" 等。\n\n该变量附加到被渲染的实体上，默认值为 0 或 false。\n\n实体变量可用于在帧之间存储动画数据",
  "entity_model_features.config.variable_explanation.entity_variable.title": "实体变量",
  "entity_model_features.config.variable_explanation.false": "常量值\nfalse",
  "entity_model_features.config.variable_explanation.fluid_depth": "淹没实体上方和下方的流体深度，未淹没时为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_down": "淹没实体下方的流体深度，未淹没时为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_up": "淹没实体上方的流体深度，未淹没时为 0",
  "entity_model_features.config.variable_explanation.frame_time": "自上一帧以来经过的时间（以秒为单位）",
  "entity_model_features.config.variable_explanation.head_pitch": "头部俯仰角（X 轴旋转）",
  "entity_model_features.config.variable_explanation.head_yaw": "头部偏航角（Y 轴旋转）",
  "entity_model_features.config.variable_explanation.health": "实体的当前生命值",
  "entity_model_features.config.variable_explanation.height_above_ground": "实体距离地面的高度。\n地面指实体下方具有碰撞体积的最高方块",
  "entity_model_features.config.variable_explanation.hurt_time": "实体受伤的持续时间。从 10 倒计时至 0",
  "entity_model_features.config.variable_explanation.id": "实体的唯一数字标识符\n对于同一实体始终相同",
  "entity_model_features.config.variable_explanation.is_aggressive": "如果实体对玩家或其他实体具有攻击性",
  "entity_model_features.config.variable_explanation.is_alive": "如果实体存活",
  "entity_model_features.config.variable_explanation.is_blocking": "如果实体正用盾牌格挡",
  "entity_model_features.config.variable_explanation.is_burning": "如果实体着火",
  "entity_model_features.config.variable_explanation.is_child": "如果实体处于幼年状态",
  "entity_model_features.config.variable_explanation.is_climbing": "如果实体正在攀爬可攀爬方块，或是蜘蛛在墙上",
  "entity_model_features.config.variable_explanation.is_crawling": "如果实体正在匍匐前进",
  "entity_model_features.config.variable_explanation.is_glowing": "如果实体拥有发光效果",
  "entity_model_features.config.variable_explanation.is_hurt": "如果实体正在受到伤害",
  "entity_model_features.config.variable_explanation.frame_counter": "当前帧的索引（0 到 720719，然后重置为 0）",
  "entity_model_features.config.variable_explanation.is_in_ground": "如果三叉戟插在地面上",
  "entity_model_features.config.variable_explanation.is_in_gui": "如果实体在 GUI 界面内",
  "entity_model_features.config.variable_explanation.is_in_hand": "如果实体被握在您手中",
  "entity_model_features.config.variable_explanation.is_in_item_frame": "如果实体在物品展示框中",
  "entity_model_features.config.variable_explanation.is_in_lava": "如果实体接触熔岩",
  "entity_model_features.config.variable_explanation.is_in_water": "如果实体接触水",
  "entity_model_features.config.variable_explanation.is_invisible": "如果实体拥有隐身效果/NBT 标签",
  "entity_model_features.config.variable_explanation.is_on_ground": "如果实体接触地面",
  "entity_model_features.config.variable_explanation.is_on_head": "如果实体被戴在另一个实体的头上",
  "entity_model_features.config.variable_explanation.is_on_shoulder": "如果鹦鹉停在您的肩膀上",
  "entity_model_features.config.variable_explanation.is_ridden": "如果实体被另一个实体骑乘",
  "entity_model_features.config.variable_explanation.is_riding": "如果实体正在骑乘另一个实体",
  "entity_model_features.config.variable_explanation.is_sitting": "如果猫/狼/鹦鹉处于坐姿",
  "entity_model_features.config.variable_explanation.is_sneaking": "如果猫/豹猫正在潜行",
  "entity_model_features.config.variable_explanation.is_jumping": "如果活体生物正在跳跃",
  "entity_model_features.config.variable_explanation.is_sprinting": "如果猫/豹猫正在疾跑",
  "entity_model_features.config.variable_explanation.is_tamed": "如果猫/狼/鹦鹉已被驯服",
  "entity_model_features.config.variable_explanation.is_wet": "如果实体处于水中/雨中",
  "entity_model_features.config.variable_explanation.is_right_handed": "如果玩家是右撇子",
  "entity_model_features.config.variable_explanation.is_swimming": "如果实体正在游泳",
  "entity_model_features.config.variable_explanation.is_gliding": "如果实体正在滑翔",
  "entity_model_features.config.variable_explanation.is_first_person_hand": "如果游戏当前正在渲染第一人称手部",
  "entity_model_features.config.variable_explanation.limb_speed": "肢体移动速度。范围从 0 到 1（静止 = 0，疾跑 = 1）",
  "entity_model_features.config.variable_explanation.limb_swing": "肢体动画计数器。当实体移动时，以游戏刻为单位递增",
  "entity_model_features.config.variable_explanation.max_health": "实体的最大生命值",
  "entity_model_features.config.variable_explanation.model_part": "模型变量使用以下格式指定：\n\"<model>.<variable_name>\"\n\n其中 model 可以是：\n\"this\" - 当前自定义模型\n\"part\" - 此自定义模型所附加的原始部件模型\n\"<part>\" - 按部件名称指定的原始模型\n\"<id>\" - 按 ID 指定的自定义模型\n\"<part>:<sub_id>:<sub_sub_id>:...\" - （层级式）从指定名称的原始部件模型开始，然后按 ID 逐级查找子模型\n\"<id>:<sub_id>:<sub_sub_id>:...\" - （层级式）从指定 ID 的模型开始，然后按 ID 逐级查找子模型\n\n如果存在重复名称或 ID，将使用最先找到的模型。\n通过 ID 查找模型时会进行深度搜索，即使在层级式写法中也是如此。\n\n层级式写法允许复用模型组（JSON 部件模型）用于不同部件。\n例如，一个手部模型（\"shoulder:upper_arm:elbow:forearm:palm:finger[1.5]\"）可同时用于左手和右手。\n动画中可使用 \"left_hand:finger1\" 表示左手拇指，\"right_hand:finger1\" 表示右手拇指。\n在层级式路径中，中间的父级可以省略。\n\n变量名说明：\ntx, ty, tz    - X、Y、Z 方向的平移\nrx, ry, rz    - 绕 X、Y、Z 轴的旋转\nsx, sy, sz    - X、Y、Z 方向的缩放\nvisible       - 是否显示该模型及其子模型（布尔值）\nvisible_boxes - 是否仅显示该模型本身，不影响子模型（布尔值）",
  "entity_model_features.config.variable_explanation.model_part.title": "模型部件变量",
  "entity_model_features.config.variable_explanation.move_forward": "实体当前朝其面朝方向的移动分量。取值范围为 -1 到 1，表示玩家当前移动向量在单位圆上的 Y 轴截距。1 表示向前移动，-1 表示向后移动",
  "entity_model_features.config.variable_explanation.move_strafing": "实体当前朝其面朝方向右侧 90 度方向的移动分量。取值范围为 -1 到 1，表示玩家当前移动向量在单位圆上的 X 轴截距",
  "entity_model_features.config.variable_explanation.nan": "非数字（Not a Number）\n运行时会抛出异常\n用于调试",
  "entity_model_features.config.variable_explanation.pi": "常量值\n3.1415926",
  "entity_model_features.config.variable_explanation.is_using_item": "实体当前是否正在使用物品，例如玩家右键使用水桶",
  "entity_model_features.config.variable_explanation.is_holding_item_right": "实体的右手槽位是否持有物品",
  "entity_model_features.config.variable_explanation.is_holding_item_left": "实体的左手槽位是否持有物品",
  "entity_model_features.config.variable_explanation.player_pos": "客户端玩家当前的世界坐标",
  "entity_model_features.config.variable_explanation.player_rot": "客户端玩家当前的世界朝向。正北方向为 0",
  "entity_model_features.config.variable_explanation.pos": "实体当前的世界坐标",
  "entity_model_features.config.variable_explanation.render_variable": "渲染变量\nrender.shadow_size\n - 实体下方阴影的大小\nrender.shadow_opacity\n - 阴影的透明度\nrender.shadow_offset_x, render.shadow_offset_z\n - 阴影的位置偏移\nrender.leash_offset_x, render.leash_offset_y, render.leash_offset_z\n - 皮带（拴绳）连接点的位置",
  "entity_model_features.config.variable_explanation.render_variable.title": "渲染变量",
  "entity_model_features.config.variable_explanation.rot": "实体当前的世界朝向。正北方向为 0",
  "entity_model_features.config.variable_explanation.rule_index": "当前匹配的随机模型规则索引。默认为 0",
  "entity_model_features.config.variable_explanation.swing_progress": "实体当前攻击动作的进度。从 0 计数到 1",
  "entity_model_features.config.variable_explanation.time": "游戏总时间（以 tick 为单位），与昼夜循环无关",
  "entity_model_features.config.variable_explanation.true": "常量值\ntrue",
  "entity_model_features.config.models": "所有模型",
  "entity_model_features.config.models.enabled": "启用模型",
  "entity_model_features.config.models.enabled.tooltip": "设置是否加载指定的 .jem 模型文件",
  "entity_model_features.config.models.part_names": "此模型的部件名称",
  "entity_model_features.config.models.export": "导出模型为 .jem 文件",
  "entity_model_features.config.models.export.tooltip": "将此模型导出为 .jem 文件，保存至目录 \"MC_DIRECTORY/emf/export\"。\n该文件可在 Blockbench 中打开，包含自定义模型所需的所有数据，\n包括轴心点、方块和 UV 映射。\n日志中还会输出额外信息，例如如何将此 .jem 文件放入资源包中使用",
  "entity_model_features.config.models.export.success": "模型导出成功",
  "entity_model_features.config.models.export.fail": "无法导出模型，原因：",
  "entity_model_features.config.models.arrows": "arrow.jem 和 spectral_arrow.jem 不会在此列出，但两者均受支持",
  "entity_model_features.config.models.cape": "\nplayer_cape.jem 不会在此列出，但也受支持。它是 player.jem 的精确副本，仅包含 'cloak'（披风）部件",
  "entity_model_features.config.variables": "变量",
  "entity_model_features.config.functions": "函数",
  "entity_model_features.config.player_settings": "玩家设置",
  "entity_model_features.config.only_client": "仅修改你自己的玩家模型",
  "entity_model_features.config.only_client.tooltip": "启用后，自定义玩家模型将仅应用于你自己，\n在多人游戏中忽略其他玩家的模型",
  "entity_model_features.config.math": "动画数学细节",
  "entity_model_features.config.math.explain": "本节提供 EMF 自定义实体模型动画中可用的数学函数和变量的详细信息。\n包括其他模组通过 EMF API 添加的内容。\n点击任意函数或变量可查看更详细的说明",
  "entity_model_features.config.variables.explain": "列出当前所有已注册、可用于 EMF 自定义实体模型动画的数学变量。\n点击任一变量可查看详细说明",
  "entity_model_features.config.functions.explain": "列出当前所有已注册、可用于 EMF 自定义实体模型动画的数学函数。\n点击任一函数可查看详细说明",
  "entity_model_features.suffix_property": "模型后缀（可选）\n匹配实体模型上次被设置的随机模型后缀编号\n默认为 0\n示例：modelSuffix.1= 2 4 6\n§amodelSuffix.<n>=<列表>",
  "entity_model_features.rule_property": "模型规则（可选）\n匹配实体模型上次匹配的随机模型规则编号\n默认为 0\n示例：modelRule.1= 2 4 6\n§amodelRule.<n>=<列表>",
  "entity_model_features.var_property": "实体变量（浮点数，可选）\n匹配实体的 CEM 动画变量值\n默认为 0\n示例：（对于动画变量 'var.xyz'）var.1.xyz= 2 4 6\n§avar.<n>.<变量名>=<列表>",
  "entity_model_features.varb_property": "实体变量（布尔值，可选）\n匹配实体的 CEM 动画变量值\n默认为 false\n示例：（对于动画变量 'varb.xyz'）varb.1.xyz=true\n§avarb.<n>.<变量名>=<true|false>",
  "entity_model_features.global_var_property": "全局变量（浮点数，可选）\n匹配 CEM 动画的全局变量值\n默认为 0\n示例：（对于动画变量 'global_var.xyz'）global_var.1.xyz= 2 4 6\n§aglobal_var.<n>.<变量名>=<列表>",
  "entity_model_features.global_varb_property": "全局变量（布尔值，可选）\n匹配 CEM 动画的全局变量值\n默认为 false\n示例：（对于动画变量 'global_varb.xyz'）global_varb.1.xyz=true\n§aglobal_varb.<n>.<变量名>=<true|false>",
  "entity_model_features.config.variable_explanation.global_variable": "全局变量使用格式 \"global_var.<名称>\"（浮点数）或 \"global_varb.<名称>\"（布尔值）。\n名称可以是任意字符串，例如 \"global_var.xyz\"、\"global_var.last_rx\" 等。\n该变量全局保存，默认值为 0 或 false。\n全局变量适用于多个实体之间共享动画数据",
  "entity_model_features.config.variable_explanation.global_variable.title": "全局变量",
  "entity_model_features.config.variable_explanation.optifine_parts": "OptiFine 部件名称：",
  "entity_model_features.config.variable_explanation.unknown_parts": "未映射的部件名称：",
  "entity_model_features.config.prevent_hand": "禁用第一人称手部动画",
  "entity_model_features.config.reset_player": "每次渲染时重置玩家模型",
  "entity_model_features.config.reset_player.tooltip": "启用后，EMF 将在玩家每次渲染前重置所有原版部件的变换。\n仅在存在自定义玩家模型时生效。\n这并非默认行为，但由于大量模组会修改玩家动画，\n此设置能显著降低玩家动画在不同模组和动画包之间的兼容难度。\n例如玩家表情模组。\n不过，资源包制作者仍需为此做相应适配工作",
  "entity_model_features.config.models.file_names": "文件名与位置",
  "entity_model_features.config.prevent_hand.tooltip": "启用后，将强制禁止所有自定义 EMF 动画在第一人称手部模型上播放",
  "entity_model_features.config.models_text": "这些是可通过 EMF 修改的所有模型。\n这些界面仅显示/导出这些模型的未修改状态信息。\n若要查看模型当前的实际状态，请在游戏中观察",
  "entity_model_features.config.ebe_warn.1": "部分 EBE 模组选项已被 EMF 强制禁用",
  "entity_model_features.config.ebe_warn.2": "这是因为某个资源包正在为该方块实体加载自定义模型",
  "entity_model_features.config.ebe_warn.3": "当前已禁用以下选项：",
  "entity_model_features.config.ebe_warn.4": "您可以在 EMF 的模型设置中更改此行为",
  "entity_model_features.config.variation_base": "变体模型需依赖基础模型",
  "entity_model_features.config.variation_base.tooltip": "在 OptiFine 中，为变体模型提供基础模型是一种最佳实践，因为 OptiFine 对此处理非常不一致。\n启用此设置后，若不存在 'pig.jem'，则 'pig2.jem' 将不会生效。\nEMF 本身不要求此依赖，但若启用此选项，将强制执行以保持与 OptiFine 的兼容性。\n您可以通过 EMF 设置中的“模型 > 所有模型 > *模型* > 导出”轻松获取默认基础模型，\n或者直接禁用此设置",
  "entity_model_features.config.double_chest_fix": "修复双层箱子模型的日志错误",
  "entity_model_features.config.double_chest_fix.tooltip": "由于双层箱子模型 'chest_large.jem' 在代码中必须拆分为左右两半，\n可能会产生大量关于缺失左/右半部分的日志警告。\n启用此选项可消除此类日志，并在一定程度上修复动画引用对侧箱子的问题。\n但仍强烈建议将左右两侧的动画分开编写。\n此选项存在是因为其他修改箱子模型的模组可能与此冲突",
  "entity_model_features.config.iris_shadow_skip": "跳过 Iris 阴影通道的动画",
  "entity_model_features.config.iris_shadow_skip.tooltip": "启用后，实体模型将不会在每帧中为普通渲染和 Iris 阴影通道各动画一次。\n此选项应始终保持开启，仅因未来 Iris API 可能发生破坏性变更而保留为可选项"
}